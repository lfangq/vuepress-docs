---
title: 类型系统
date: 2023-01-30 08:58:49
order: 2
categories: 
  - 笔记
tags: 
  - TypeScript
---

## 类型声明

类型声明的写法，一律为在标识符后面添加`冒号 + 类型`。函数参数和返回值，也是这样来声明类型。

```ts
// 变量声明
const name: string = 'Lfangq';

// 函数声明
function add(a: number, b: number): number {
  return a + b;
}
```

## 类型推断

在变量声明时，如果未指定类型，则 TypeScript 会根据变量的初始值进行类型推断。

```ts
let foo = 123; // foo 的类型推断为 number
```

## 特殊类型

### any

`any` 类型是 TypeScript 中最灵活的类型，它可以接受任何值。变量类型一旦设为`any`，TypeScript 实际上会关闭这个变量的类型检查。即使有明显的类型错误，只要句法正确，都不会报错。

```ts
let x: any = "hello";

x(1); // 不报错
x.foo = 100; // 不报错
```

实际开发中，any类型主要适用以下两个场合:

(1) 出于特殊原因，需要关闭某些变量的类型检查，就可以把该变量的类型设为 `any`。

(2) 为了适配以前老的 JavaScript 项目，让代码快速迁移到 TypeScript，可以把变量类型设为 `any`。有些年代很久的大型 JavaScript 项目，尤其是别人的代码，很难为每一行适配正确的类型，这时你为那些类型复杂的变量加上`any`，TypeScript 编译时就不会报错。

### unkown

`unkown` 类型是 `any` 类型的子类型，它只能赋值给 `any` 类型和 `unkown` 类型。

`unknown` 类型跟 `any` 类型的不同之处在于，它不能直接使用。主要有以下几个限制:

* `unknown` 类型的变量，不能直接赋值给其他类型的变量（除了 `any` 类型和 `unknown` 类型）。

* 不能直接调用 `unknown` 类型变量的方法和属性。

* `unknown` 类型变量能够进行的运算是有限的，只能进行比较运算（运算符`==`、`===`、`!=`、`!==`、`||`、`&&`、`?`）、取反运算（运算符!）、`typeof` 运算符和 `instanceof` 运算符这几种，其他运算都会报错。

通过“类型缩小”，使用unknown类型变量。 所谓“类型缩小”，就是缩小unknown变量的类型范围，确保不会出错。如下：

```ts
let a: unknown = 1;

if (typeof a === "number") {
  let r = a + 10; // 正确
}
```
在集合论上，unknown也可以视为所有其他类型（除了any）的全集，所以它和any一样，也属于 TypeScript 的顶层类型。

### never

never 类型是所有类型的子类型，它表示一个永远不存在的值的类型。多用于声明错误的类型。

```ts
function f(): never {
  throw new Error("Error");
}
```

TypeScript 有两个“顶层类型”（any和unknown），但是“底层类型”只有never唯一一个。

## 基本类型

TypeScript 继承了 JavaScript 的类型设计，以下 8 种类型可以看作 TypeScript 的基本类型。

* boolean
* string
* number
* bigint
* symbol
* object
* undefined
* null

:::warning
注意，上面所有类型的名称都是小写字母，首字母大写的Number、String、Boolean等在 JavaScript 语言中都是内置对象，而不是类型名称。另外，undefined 和 null 既可以作为值，也可以作为类型，取决于在哪里使用它们。
:::

### boolean 类型

```ts
const x: boolean = true;
```

### string 类型

```ts
const x: string = "hello";
const y: string = `${x} world`;
```

### number 类型

`number`类型包含所有整数、浮点数和非十进制数。

```ts
const x: number = 123; // 整数
const y: number = 3.14; // 浮点数
const z: number = 0xffff; // 非十进制数
```

### bigint 类型

`bigint` 类型包含所有的大整数, 但 `bigint` 与 `number` 类型不兼容。

```ts
const x: bigint = 123n;
const y: bigint = 0xffffn;

const x: bigint = 123; // 报错
const y: bigint = 3.14; // 报错
```

:::warning
注意，bigint 类型是 ES2020 标准引入的。如果使用这个类型，TypeScript 编译的目标 JavaScript 版本不能低于 ES2020（即编译参数target不低于es2020）。
:::

### symbol 类型

```ts
const x: symbol = Symbol();
```

### object 类型

根据 JavaScript 的设计，object 类型包含了所有对象、数组和函数。

```ts
const x: object = { foo: 123 };
const y: object = [1, 2, 3];
const z: object = (n: number) => n + 1;
```

### undefined 类型，null 类型

undefined 和 null 是两种独立类型，它们各自都只有一个值。

undefined 类型只包含一个值undefined，表示未定义（即还未给出定义，以后可能会有定义）。null 类型也只包含一个值null，表示为空（即此处没有值）。

```ts
const x: undefined = undefined;
const y: null = null;
```

:::warning
注意，如果没有声明类型的变量，被赋值为`undefined`或`null`，它们的类型会被推断为`any`。如果希望避免这种情况，则需要打开编译选项`strictNullChecks`。
:::

`undefined` 类型，`null` 类型特殊性:

任何其他类型的变量都可以赋值为 `undefined` 或 `null`。

:::tip
TypeScript 提供了一个编译选项`strictNullChecks`。只要打开这个选项，`undefined` 和 `null` 就不能赋值给其他类型的变量（除了`any`类型和`unknown`类型）。
:::

## 包装对象类型

JavaScript 的 8 种类型之中，`undefined` 和 `null` 其实是两个特殊值，`object` 属于复合类型，剩下的五种属于`原始类型（primitive value）`，代表最基本的、不可再分的值, 这五种原始类型的值，都有对应的`包装对象（wrapper object）`。所谓“包装对象”，指的是这些值在需要时，会自动产生的对象。

```ts
"hello".charAt(1); // 'e'
```

五种包装对象之中，`symbol` 类型和 `bigint` 类型无法直接获取它们的包装对象（即 `Symbol()` 和 `BigInt()` 不能作为构造函数使用），但是剩下三种 `Boolean()`、 `String()`、 `Number()`可以。

```ts
const s = new String("hello");
typeof s; // 'object', 包装对象返回类型是object, 不是string
s.charAt(1); // 'e'
```

由于包装对象的存在，导致每一个原始类型的值都有`包装对象`和`字面量`两种情况, 其中，大写类型同时包含包装对象和字面量两种情况，小写类型只包含字面量，不包含包装对象。如下

```ts
// 包装对象
const s1: String = "hello"; // 正确
const s2: String = new String("hello"); // 正确

// 字面量
const s3: string = "hello"; // 正确
const s4: string = new String("hello"); // 报错
```

:::tip
建议只使用小写类型，不使用大写类型。因为绝大部分使用原始类型的场合，都是使用字面量，不使用包装对象。而且，TypeScript 把很多内置方法的参数，定义成小写类型，使用大写类型会报错。

还有 `Symbol()` 和 `BigInt()` 这两个函数不能当作构造函数使用，所以没有办法直接获得 `symbol` 类型和 `bigint` 类型的包装对象，因此 `Symbol` 和 `BigInt` 这两个类型虽然存在，但是完全没有使用的理由。
:::

## Object 类型与 object 类型

`Object` 类型是所有对象的父类型(所有可以转成对象的值，都是`Object`类型，这囊括了几乎所有的值, 除了 `undefined` 和 `null` )，而 `object` 类型是所有对象字面量的父类型 (只包含对象、数组和函数，不包括原始类型的值)。

```ts
// Object 类型
let obj: Object;

obj = true;
obj = "hi";
obj = 1;
obj = { foo: 123 };
obj = [1, 2];
obj = (a: number) => a + 1;

// undefined 和 null这两个值不能转为对象
obj = undefined; // 报错
obj = null; // 报错

// object 类型
let obj: object;

obj = { foo: 123 };
obj = [1, 2];
obj = (a: number) => a + 1;
obj = true; // 报错
obj = "hi"; // 报错
obj = 1; // 报错
```

变量类型指定为`object`在以下几种情况下很有用：

* 通用对象处理：当你编写一个函数，这个函数接受任何类型的对象作为参数，但你不关心这些对象的内部结构时。使用object类型可以确保传入的参数确实是一个对象，而不是其他原始类型（如`string`、`number`、`boolean`、`null`或`undefined`）。

```ts
function printObjectKeys(obj: object) {  
  for (const key in obj) {  
    if (obj.hasOwnProperty(key)) {  
      console.log(key);  
    }  
  }  
}
```

* 避免自动类型推断：TypeScript具有强大的类型推断能力，但有时候你可能想要明确地指定一个变量是`object`类型，以避免TypeScript基于上下文自动推断出更具体的类型。这有助于确保代码的一致性和清晰度。

* 与JavaScript代码交互：当TypeScript代码需要与JavaScript代码交互，且你只知道JavaScript部分返回一个对象，但不确定具体结构时，使用`object`类型可以提供一个基本的类型安全保证。

* 类型兼容性：在某些复杂的类型兼容性检查场景中，使用`object`类型可以帮助你更精确地控制哪些类型被认为是兼容的。

* 函数重载：在定义函数重载时，如果有一个重载版本接受任何对象，而另一个版本接受具有特定属性的对象，那么接受任何对象的版本可能会使用`object`类型。

:::tip
大多数时候，我们使用对象类型，只希望包含真正的对象，不希望包含原始类型。所以，建议总是使用小写类型object，不使用大写类型Object。
:::
:::warning
注意，无论是大写的Object类型，还是小写的object类型，都只包含 JavaScript 内置对象原生的属性和方法，用户自定义的属性和方法都不存在于这两个类型之中。
```ts
const o1: Object = { foo: 0 };
const o2: object = { foo: 0 };

o1.toString(); // 正确
o1.foo; // 报错

o2.toString(); // 正确
o2.foo; // 报错
```
:::

## 值类型

TypeScript 规定，单个值也是一种类型，称为“值类型”。当 TypeScript 推断类型时，遇到const命令声明的变量，如果代码里面没有注明类型，就会推断该变量是`值类型`。

```ts
// x 的类型是 "https"
const x = "https";

// y 的类型是 string
const y: string = "https";

// z 的类型是 string
let z = "https";
```

只包含单个值的`值类型`，用处不大。实际开发中，往往将多个值结合，作为联合类型使用。

:::warning
注意，const命令声明的变量，如果赋值为对象，并不会推断为值类型。
```ts
// x 的类型是 { foo: number }
const x = { foo: 1 };
```
:::

## 联合类型

联合类型（union types）指的是多个类型组成的一个新类型，使用符号`|`表示。

联合类型 `A|B` 表示，任何一个类型只要属于 `A` 或 `B`，就属于联合类型 `A|B`。

```ts
let x: string | number;

x = 123; // 正确

x = "abc"; // 正确

let setting: true | false;

let gender: "male" | "female";

let rainbowColor: "赤" | "橙" | "黄" | "绿" | "青" | "蓝" | "紫";
```

如果一个变量有多种类型，读取该变量时，往往需要进行“类型缩小”（type narrowing），区分该值到底属于哪一种类型，然后再进一步处理。

“类型缩小”是 TypeScript 处理联合类型的标准方法，凡是遇到可能为多种类型的场合，都需要先缩小类型，再进行处理。实际上，联合类型本身可以看成是一种“类型放大”（type widening），处理时就需要“类型缩小”（type narrowing）。

```ts
function printId(id: number | string) {
  console.log(id.toUpperCase()); // 报错
}

// 类型缩小
function printId(id: number | string) {
  if (typeof id === "string") {
    console.log(id.toUpperCase());
  } else {
    console.log(id);
  }
}

// “类型缩小”的另一个例子
function getPort(scheme: "http" | "https") {
  switch (scheme) {
    case "http":
      return 80;
    case "https":
      return 443;
  }
}
```

## 交叉类型

交叉类型（intersection types）指的多个类型组成的一个新类型，使用符号 `&` 表示。

交叉类型`A&B`表示，任何一个类型必须同时属于`A`和`B`，才属于交叉类型`A&B`，即交叉类型同时满足`A`和`B`的特征。c

交叉类型的主要用途:

* 对象的合成
```ts
let obj: { foo: string } & { bar: string };

obj = {
  foo: "hello",
  bar: "world",
};
```

* 为对象类型添加新属性
```ts
type A = { foo: number };

type B = A & { bar: number };
```

## type 命令

`type` 命令用来定义一个类型的别名。

```ts
type Age = number;

let age: Age = 55;
```

`type` 命令特点：

* 别名不允许重名

* 别名的作用域是块级作用域

* 别名支持使用表达式，也可以在定义一个别名时，使用另一个别名，即别名允许嵌套。

```ts
// 别名不允许重名
type Color = "red";
type Color = "blue"; // 报错

// 别名的作用域是块级作用域
type Color = "red";

if (Math.random() < 0.5) {
  type Color = "blue";
}

// 别名支持使用表达式，也可以在定义一个别名时，使用另一个别名，即别名允许嵌套。
type World = "world";
type Greeting = `hello ${World}`;
```
:::warning
`type` 命令属于类型相关的代码，编译成 JavaScript 的时候，会被全部删除。
:::

## typeof 运算符

在JavaScript 里面，typeof运算符只可能返回八种结果，而且都是字符串。TypeScript 将typeof运算符移植到了类型运算，它的操作数依然是一个值，但是返回的不是字符串，而是该值的 TypeScript 类型。

```ts
// 在JavaScript
typeof undefined; // "undefined"
typeof true; // "boolean"
typeof 1337; // "number"
typeof "foo"; // "string"
typeof {}; // "object"
typeof parseInt; // "function"
typeof Symbol(); // "symbol"
typeof 127n; // "bigint"

// 在TypeScript
const a = { x: 0 };

type T0 = typeof a; // { x: number }
type T1 = typeof a.x; // number
```

## 块级类型声明

TypeScript 支持块级类型声明，即类型可以声明在代码块（用大括号表示）里面，并且只在当前代码块有效。

```ts
if (true) {
  type T = number;
  let v: T = 5;
} else {
  type T = string;
  let v: T = "hello";
}
```

## 类型的兼容

TypeScript 的类型存在兼容关系，某些类型可以兼容其他类型。

兼容规则如下:

* 凡是可以使用父类型的地方，都可以使用子类型，但是反过来不行

```ts
let a: "hi" = "hi";
let b: string = "hello";

// a 是 b 的子类型，b 是 a 的父类型
b = a; // 正确
a = b; // 报错
```

## 数组类型

JavaScript 数组在 TypeScript 里面分成两种类型，分别是数组（array）和元组（tuple）。

### 数组（array）

数组(array) 有一个根本特征：所有成员的`类型必须相同`，但是成员数量是不确定的，可以是无限数量的成员，也可以是零成员。

数组的类型有两种写法:

* 方式一：`number[]`
```ts
let arr: number[] = [1, 2, 3];

let arr: (number | string)[];

let arr: any[];
```

* 方式二：泛型写法 `Array<number>`
```ts
let arr: Array<number> = [1, 2, 3];

let arr: Array<number | string>;

let arr: Array<any>;
```

:::warning
数组由于成员数量可以动态变化，所以 TypeScript 不会对数组边界进行检查，越界访问数组并不会报错。
```ts
let arr: number[] = [1, 2, 3];
let foo = arr[3]; // 正确
```
由于数组成员的索引类型都是number，所以读取成员类型也可以写成下面这样。
```ts
type Names = string[];

// 第一个数值索引的成员类型
type FirstName = Names[0]; // string

// 所有数值索引的成员类型
type Name = Names[number]; // string

// 读取数组长度
Names["length"];
```
:::

### 数组的类型推断

如果数组变量没有声明类型，TypeScript 就会推断数组成员的类型。这时，推断行为会因为值的不同，而有所不同。

如果数组初始值是空数组，TypeScript 会推断数组类型 `any[]`，后面，为这个数组赋值时，TypeScript 会自动更新类型推断。

但是，类型推断的自动更新只发生初始值为空数组的情况。如果初始值不是空数组，类型推断就不会更新。

```ts
const arrIsNull = [];
arrIsNull; // 推断为 any[]

arrIsNull.push(123);
arrIsNull; // 推断类型为 number[]

arrIsNull.push("abc");
arrIsNull; // 推断类型为 (string|number)[]

// 推断类型为 number[]
const arr = [123];

arr.push("abc"); // 报错
```

### 只读数组，const 断言

TypeScript 允许声明只读数组，方法是在数组类型前面加上 `readonly` 关键字。

```ts
const arr: readonly number[] = [0, 1];

arr[1] = 2; // 报错
arr.push(3); // 报错
delete arr[0]; // 报错
```

只读数组还有一种声明方法，就是使用`“const 断言”`:

```ts
const arr = [0, 1] as const;

arr[0] = [2]; // 报错
```

上面示例中，`as const`告诉 TypeScript，推断类型时要把变量arr推断为只读数组，从而使得数组成员无法改变。

TypeScript 将`readonly number[]`与`number[]`视为两种不一样的类型，后者是前者的子类型。子类型继承了父类型的所有特征，并加上了自己的特征，所以子类型`number[]`可以用于所有使用父类型的场合，反过来就不行。

```ts
// 例1
let a1: number[] = [0, 1];
let a2: readonly number[] = a1; // 正确

a1 = a2; // 报错

// 例2
function getSum(s: number[]) {
  // ...
}

const arr: readonly number[] = [1, 2, 3];

getSum(arr); // 报错
```

解决上面问题的方法是使用`类型断言`，如：`getSum(arr as number[])`,详见《类型断言》一章。

:::warning
注意，`readonly`关键字不能与数组的泛型写法一起使用。
```ts
// 报错
const arr: readonly Array<number> = [0, 1];
```
TypeScript 提供了两个专门的泛型，用来生成只读数组的类型:
```ts
const a1: ReadonlyArray<number> = [0, 1];

const a2: Readonly<number[]> = [0, 1];
```
:::

### 多维数组

TypeScript 使用`T[][]`的形式，表示二维数组，`T`是最底层数组成员的类型。

```ts
var multi: number[][] = [
  [1, 2, 3],
  [23, 24, 25],
];
```

### 元组类型（tuple）

元组（tuple）是 TypeScript 特有的数据类型，JavaScript 没有单独区分这种类型。它表示成员类型可以自由设置的数组，即数组的各个成员的类型可以不同。

元组必须明确声明每个成员的类型。

```ts
const s: [string, string, boolean] = ["a", "b", true];
```

元组成员的类型可以添加问号后缀（?），表示该成员是可选的。

注意，问号只能用于元组的尾部成员，也就是说，所有可选成员必须在必选成员之后。

```ts
let a: [number, number?] = [1];
```

由于需要声明每个成员的类型，所以大多数情况下，元组的成员数量是有限的，从类型声明就可以明确知道，元组包含多少个成员，越界的成员会报错。

```ts
let x: [string, string] = ["a", "b"];

x[2] = "c"; // 报错
```

但是，使用扩展运算符（...），可以表示不限成员数量的元组。

扩展运算符用在元组的任意位置都可以，但是它后面只能是数组或元组。

```ts
type NamedNums = [string, ...number[]];

const a: NamedNums = ["A", 1, 2];
const b: NamedNums = ["B", 1, 2, 3];

// 任意位置
type t1 = [string, number, ...boolean[]];
type t2 = [string, ...boolean[], number];
type t3 = [...boolean[], string, number];
```

元组可以通过方括号，读取成员类型。

```ts
// 单个
type Tuple = [string, number];
type Age = Tuple[1]; // number

// 所有数值索引的成员类型，由于元组类型是不同的，所以返回的类型是联合类型
type Tuple = [string, number, Date];
type TupleEl = Tuple[number]; // string|number|Date
```

### 只读元组

元组也可以是只读的，不允许修改，有两种写法：

```ts
// 写法一
type t = readonly [number, string];

// 写法二 泛型写法
type t = Readonly<[number, string]>;
```

跟数组一样，只读元组是元组的父类型。所以，元组可以替代只读元组，而只读元组不能替代元组。

```ts
type t1 = readonly [number, number];
type t2 = [number, number];

let x: t2 = [1, 2];
let y: t1 = x; // 正确

x = y; // 报错
```

### 成员数量的推断

如果没有扩展运算符，TypeScript 会推断出元组的成员数量（即元组长度）。

```ts
// 下面示例会报错，原因是 TypeScript 发现元组point的长度是2，不可能等于3，这个判断无意义。
function f(point: [number, number]) {
  if (point.length === 3) {
    // 报错
    // ...
  }
}

// 下面示例会报错，原因是 TypeScript 发现point.length的类型是1|2|3，不可能等于4。
function f(point: [number, number?, number?]) {
  if (point.length === 4) {
    // 报错
    // ...
  }
}
```

如果使用了扩展运算符，TypeScript 就无法推断出成员数量。

一旦扩展运算符使得元组的成员数量无法推断，TypeScript 内部就会把该元组当成数组处理。

```ts
const myTuple: [...string[]] = ["a", "b", "c"];

if (myTuple.length === 4) {
  // 正确
  // ...
}
```

### 扩展运算符与成员数量

扩展运算符（`...`）将数组（注意，不是元组）转换成一个逗号分隔的序列，这时 TypeScript 会认为这个序列的成员数量是不确定的，因为数组的成员数量是不确定的。

这导致如果函数调用时，使用扩展运算符传入函数参数，可能发生参数数量与数组长度不匹配的报错。

```ts
const arr = [1, 2];

function add(x: number, y: number) {
  // ...
}

add(...arr); // 报错 A spread argument must either have a tuple type or be passed to a rest parameter.(2556)
```

解决这个问题的一个方法，就是把成员数量不确定的数组，写成成员数量确定的元组，再使用扩展运算符。

```ts
const arr: [number, number] = [1, 2];

function add(x: number, y: number) {
  // ...
}

add(...arr); // 正确
```

另一种写法是使用`as const`断言。

```ts
const arr = [1, 2] as const;
```

## symbol 类型

`Symbol` 是 ES2015 新引入的一种原始类型的值。它类似于字符串，但是每一个 `Symbol` 值都是独一无二的，与其他任何值都不相等。

`Symbol` 值通过`Symbol()`函数生成。在 TypeScript 里面，`Symbol` 的类型使用`symbol`表示。

```ts
let x: symbol = Symbol();
let y: symbol = Symbol();

x === y; // false
```

### unique symbol

`symbol`类型包含所有的 `Symbol` 值，但是无法表示某一个具体的 `Symbol` 值。

为了解决这个问题，TypeScript 设计了`symbol`的一个子类型`unique symbol`，它表示单个的、某个具体的 `Symbol` 值。

因为`unique symbol`表示单个值，所以这个类型的变量是不能修改值的，只能用`const`命令声明，不能用`let`声明。

由于`unique symbol` 声明的类型是唯一的，所以它不能赋给其他变量。

```ts
// 正确
const x: unique symbol = Symbol();

// 报错
let y: unique symbol = Symbol();

const z: unique symbol = x; // 报错：Type 'typeof x' is not assignable to type 'typeof z'.(2322)
```

如果要 `x` 赋值给 `z`, 可以用 `typeof` 来获取 `x` 的类型。

```ts
const z: typeof x = x;
```

:::warning
相同参数的Symbol.for()方法会返回相同的 Symbol 值。TypeScript 目前无法识别这种情况，所以可能出现多个 unique symbol 类型的变量，等于同一个 Symbol 值的情况。
```ts
const a: unique symbol = Symbol.for("foo");
const b: unique symbol = Symbol.for("foo");
```
上面示例中，变量`a`和`b`是两个不同的值类型，但是它们的值其实是相等的。
:::

`unique symbol` 类型是 `symbol` 类型的子类型，所以可以将前者赋值给后者，但是反过来就不行。

```ts
const a: unique symbol = Symbol();

const b: symbol = a; // 正确

const c: unique symbol = b; // 报错
```

`unique symbol`的作用:

* 用作属性名，这可以保证不会跟其他属性名冲突。
```ts
const x: unique symbol = Symbol();
const y: symbol = Symbol();

interface Foo {
  [x]: string; // 正确
  [y]: string; // 报错
}
```

* 用作类`（class）`的属性值，但只能赋值给类的`readonly static`属性。
```ts
class C {
  static readonly foo: unique symbol = Symbol();
}
```

### 类型推断

如果变量声明时没有给出类型，TypeScript 会自动推断某个 Symbol 值变量的类型。

* `let`命令声明的变量，推断类型为 `symbol`, 且 `let`命令声明的变量，如果赋值为另一个 `unique symbol` 类型的变量，则推断类型还是 `symbol`。

```ts
// 类型为 symbol
let x = Symbol();

// 类型为 symbol
const y = x;
```

* `const`命令声明的变量，推断类型为 `unique symbol`, 但是，`const`命令声明的变量，如果赋值为另一个 `symbol` 类型的变量，则推断类型为 `symbol`。

```ts
// 类型为 unique symbol
const x = Symbol();

// 类型为 symbol
let y = x;
```

## 函数类型

函数的类型声明，需要在声明函数时，给出参数的类型和返回值的类型。

```ts
function hello(txt: string): void {
  console.log("hello " + txt);
}
```

如果变量被赋值为一个函数，变量的类型有两种写法。

```ts
// 写法一
const hello = function (txt: string) {
  console.log("hello " + txt);
};

// 写法二
const hello: (txt: string) => void = function (txt) {
  console.log("hello " + txt);
};

// 写法二用 type 运算符优化
type Hello = (txt: string) => void;

const hello: Hello = function (txt) {
  console.log("hello " + txt);
}
```

:::warning
函数的实际参数个数，可以少于类型指定的参数个数，但是不能多于，即 TypeScript 允许省略参数。
```ts
let myFunc: (a: number, b: number) => number;

myFunc = (a: number) => a; // 正确

myFunc = (a: number, b: number, c: number) => a + b + c; // 报错
```
:::

函数类型还可以采用对象的写法, 这种写法平时很少用，但是非常合适用在一个场合：函数本身存在属性。
```ts
{
  (参数列表): 返回值
}
```
```ts
let add: {
  (x: number, y: number): number; // 对象的写法
  version: number;
};

add = function (x, y) {
  return x + y;
};
add.version = 1;
```

### Function 类型

TypeScript 提供 `Function` 类型表示函数，任何函数都属于这个类型。

```ts
function doSomething(f: Function) {
  return f(1, 2, 3);
}
```

上面示例中，参数f的类型就是`Function`，代表这是一个函数。

`Function` 类型的值都可以直接执行。

`Function` 类型的函数可以接受任意数量的参数，每个参数的类型都是`any`，返回值的类型也是`any`，代表没有任何约束，所以不建议使用这个类型，给出函数详细的类型声明会更好。

### 箭头函数

箭头函数是普通函数的一种简化写法，它的类型写法与普通函数类似。

注意，类型写在箭头函数的定义里面，与使用箭头函数表示函数类型，写法有所不同。

```ts
// 类型写在箭头函数的定义里面
函数名(参数列表): 返回值类型 => 函数体

const repeat = (str: string, times: number): string => str.repeat(times);

// 使用箭头函数表示函数类型
函数名: (参数列表) => 返回值类型

function greet(fn: (a: string) => void): void {
  fn("world");
}
```

### 可选参数

如果函数的某个参数可以省略，则在参数名后面加问号表示。

```ts
function f(x?: number) {
  return x;
}

f(undefined); // 正确

// 类型显式设为 undefined 的参数
function f(x: number | undefined) {
  return x;
}

f(); // 报错
```

参数名带有问号，表示该参数的类型实际上是`原始类型|undefined`，它有可能为`undefined`。比如，上例的x虽然类型声明为`number`，但是实际上是`number|undefined`。

但是，反过来就不成立，类型显式设为`undefined`的参数，就不能省略。

函数体内部用到可选参数时，需要判断该参数是否为`undefined`。

```ts
let myFunc: (a: number, b?: number) => number;

myFunc = function (x, y) {
  if (y === undefined) {
    return x;
  }
  return x + y;
};
```

### 参数默认值

TypeScript 函数的参数默认值写法，与 JavaScript 一致。

```ts
function createPoint(x: number = 0, y: number = 0): [number, number] {
  return [x, y];
}

createPoint(); // [0, 0]
```

:::warning
可选参数与默认值不能同时使用。
:::

### 参数解构

函数参数如果存在变量解构，类型写法如下。

```ts
function f([x, y]: [number, number]) {
  // ...
}

function sum({ a, b, c }: { a: number; b: number; c: number }) {
  console.log(a + b + c);
}
```

参数结构可以结合类型别名（`type 命令`）一起使用，代码会看起来简洁一些。

```ts
type ABC = { a: number; b: number; c: number };

function sum({ a, b, c }: ABC) {
  console.log(a + b + c);
}
```

### rest 参数

`rest` 参数表示函数剩余的所有参数，它可以是数组（剩余参数类型相同），也可能是元组（剩余参数类型不同）。

```ts
// rest 参数为数组
function joinNumbers(...nums: number[]) {
  // ...
}

// rest 参数为元组
function f(...args: [boolean, number]) {
  // ...
}
```

注意，元组需要声明每一个剩余参数的类型。如果元组里面的参数是可选的，则要使用可选参数。

```ts
function f(...args: [boolean, string?]) {}
```

```ts
function multiply(n: number, ...m: number[]) {
  return m.map((x) => n * x);
}
```

rest 参数甚至可以嵌套。

```ts
function f(...args: [boolean, ...string[]]) {
  // ...
}
```

rest 参数可以与变量解构结合使用。

```ts
function repeat(...[str, times]: [string, number]): string {
  return str.repeat(times);
}

// 等同于
function repeat(str: string, times: number): string {
  return str.repeat(times);
}
```

### readonly 只读参数

```ts
function arraySum(arr: readonly number[]) {
  // ...
  arr[0] = 0; // 报错
}
```

### void 类型

void 类型表示函数没有返回值。

```ts
function f(): void {
  console.log("hello");
}
```

`void`类型允许返回`undefined`或`null`。

```ts
function f(): void {
  return undefined; // 正确
}

function f(): void {
  return null; // 正确
}
```
:::warning
如果打开了`strictNullChecks`编译选项，那么 `void` 类型只允许返回`undefined`。如果返回`null`，就会报错。这是因为 JavaScript 规定，如果函数没有返回值，就等同于返回`undefined`。
```ts
// 打开编译选项 strictNullChecks

function f(): void {
  return undefined; // 正确
}

function f(): void {
  return null; // 报错
}
```
:::

### never 类型

`never`类型表示肯定不会出现的值。它用在函数的返回值，就表示某个函数肯定不会返回值，即函数不会正常执行结束。它主要有以下两种情况:

（1）抛出错误的函数。

```ts
function fail(msg: string): never {
  throw new Error(msg);
}
```

注意，只有抛出错误，才是 `never` 类型。如果显式用`return`语句返回一个 `Error` 对象，返回值就不是 `never` 类型。


（2）无限执行的函数。

```ts
const sing = function (): never {
  while (true) {
    console.log("sing");
  }
};
```

### 高阶函数

一个函数的返回值还是一个函数，那么前一个函数就称为`高阶函数（higher-order function）`。

```ts
(someValue: number) => (multiplier: number) => someValue * multiplier;
```

### 函数重载

有些函数可以接受不同类型或不同个数的参数，并且根据参数的不同，会有不同的函数行为。这种根据参数类型不同，执行不同逻辑的行为，称为`函数重载（function overload）`。

函数重载的声明限制:

* 函数重载的每个类型声明之间，以及类型声明与函数实现的类型之间，不能有冲突。

* 类型最宽的声明应该放在最后面，防止覆盖其他类型声明。

```ts
function reverse(str: string): string;
function reverse(arr: any[]): any[];
function reverse(stringOrArray: string | any[]): string | any[] {
  if (typeof stringOrArray === "string")
    return stringOrArray.split("").reverse().join("");
  else return stringOrArray.slice().reverse();
}
```

对象的方法也可以使用重载：

```ts
class StringBuilder {
  #data = "";

  add(num: number): this;
  add(bool: boolean): this;
  add(str: string): this;
  add(value: any): this {
    this.#data += String(value);
    return this;
  }

  toString() {
    return this.#data;
  }
}
```
函数重载也可以用来精确描述函数参数与返回值之间的对应关系:
```ts
function createElement(tag: "a"): HTMLAnchorElement;
function createElement(tag: "canvas"): HTMLCanvasElement;
function createElement(tag: "table"): HTMLTableElement;
function createElement(tag: string): HTMLElement {
  // ...
}

// 这个示例的函数重载，也可以用对象表示
type CreateElement = {
  (tag: "a"): HTMLAnchorElement;
  (tag: "canvas"): HTMLCanvasElement;
  (tag: "table"): HTMLTableElement;
  (tag: string): HTMLElement;
};
```

:::tip
由于重载是一种比较复杂的类型声明方法，为了降低复杂性，一般来说，如果可以的话，应该优先使用联合类型替代函数重载。
:::

### 构造函数

构造函数的类型写法，就是在参数列表前面加上`new`命令。

```ts
class Animal {
  numLegs: number = 4;
}

type AnimalConstructor = new () => Animal;

function create(c: AnimalConstructor): Animal {
  return new c();
}

const a = create(Animal);
```

构造函数还有另一种类型写法，就是采用对象形式:

```ts
type F = {
  new (s: string): object;
};
```

某些函数既是构造函数，又可以当作普通函数使用，比如Date()。这时，类型声明可以写成下面这样:

```ts
type F = {
  new (s: string): object;
  (n?: number): number;
};
```
:::warning
TS不能用`es5`的形式来创建构造函数，因为`this`会报错。
:::

## 对象类型

对象类型的最简单声明方法，就是使用大括号表示对象，在大括号内部声明每个属性和方法的类型。

```ts
const obj: {
  x: number;
  y: number;
} = { x: 1, y: 1 };
```

对象类型限制:

* 一旦声明了类型，对象赋值时，就不能缺少指定的属性，也不能有多余的属性。

* 不能读写不存在的属性。

* 不能删除类型声明中存在的属性，修改属性值是可以的。

对象的方法使用函数类型描述:

```ts
const obj: {
  x: number;
  y: number;
  add(x: number, y: number): number;
  // 或者写成
  // add: (x:number, y:number) => number;
} = {
  x: 1,
  y: 1,
  add(x, y) {
    return x + y;
  },
};
```

对象类型可以使用方括号读取属性的类型。

```ts
type User = {
  name: string;
  age: number;
};
type Name = User["name"]; // string
```

:::warning
注意，TypeScript 不区分对象自身的属性和继承的属性，一律视为对象的属性。
```ts
interface MyInterface {
  toString(): string; // 继承的属性
  prop: number; // 自身的属性
}

// obj只写了prop属性，但是不报错。因为它可以继承原型上面的toString()方法。
const obj: MyInterface = {
  // 正确
  prop: 123,
};
```
:::

### 可选属性

如果某个属性是可选的（即可以忽略），需要在属性名后面加一个问号。

```ts
const obj: {
  x: number;
  y?: number;
} = { x: 1 };
```

读取可选属性之前，必须检查一下是否为`undefined`。

```ts
// 写法一
let firstName = user.firstName === undefined ? "Foo" : user.firstName;
let lastName = user.lastName === undefined ? "Bar" : user.lastName;

// 写法二
let firstName = user.firstName ?? "Foo";
let lastName = user.lastName ?? "Bar";
```

### 属性名的索引类型

如果对象的属性非常多，一个个声明类型就很麻烦，而且有些时候，无法事前知道对象会有多少属性，比如外部 API 返回的对象。这时 TypeScript 允许采用属性名表达式的写法来描述类型，称为“属性名的索引类型”。

索引类型里面，最常见的就是属性名的字符串索引。

```ts
type MyObj = {
  [property: string]: string;
};

const obj: MyObj = {
  foo: "a",
  bar: "b",
  baz: "c",
};
```
对象可以同时有多种类型的属性名索引，比如同时有数值索引和字符串索引。但是，数值索引不能与字符串索引发生冲突，必须服从后者，这是因为在 JavaScript 语言内部，所有的数值属性名都会自动转为字符串属性名。

```ts
type MyType = {
  [x: number]: boolean; // 报错
  [x: string]: string;
};

// 不报错
type MyType = {
    [x: symbol]: string;
    [x: number]: string;
};
```

属性的索引类型写法，建议谨慎使用，因为属性名的声明太宽泛，约束太少。另外，属性名的数值索引不宜用来声明数组，因为采用这种方式声明数组，就不能使用各种数组方法以及`length`属性，因为类型里面没有定义这些东西。

```ts
type MyArr = {
  [n: number]: number;
};

const arr: MyArr = [1, 2, 3];
arr.length; // 报错
```

### 解构赋值

解构赋值的类型写法，跟为对象声明类型是一样的。

```ts
const { id, name, price }: { id: string; name: string; price: number; } = product;
```

注意，目前没法为解构变量指定类型，因为对象解构里面的冒号，JavaScript 指定了其他用途:

```ts
let { x: foo, y: bar } = obj;

// 等同于
let foo = obj.x;
let bar = obj.y;
```

### 结构类型原则

只要对象 `B` 满足 对象 `A` 的结构特征，TypeScript 就认为对象 `B` 兼容对象 `A` 的类型，这称为`“结构类型”原则（structual typing）`。

```ts
type Person = {
    name: string;
};

type Student = {
    name: string;
    age: number;
}

const student: Student = {
    name: '张三',
    age: 14
};

const person: Person = student;
```

如果类型 `B` 可以赋值给类型 `A`，TypeScript 就认为 `B` 是 `A` 的子类型（subtyping），`A` 是 `B` 的父类型。子类型满足父类型的所有结构特征，同时还具有自己的特征。凡是可以使用父类型的地方，都可以使用子类型，即子类型兼容父类型。

这种设计有时会导致令人惊讶的结果。
```ts
type myObj = {
  x: number;
  y: number;
};

function getSum(obj: myObj) {
  let sum = 0;

  for (const n of Object.keys(obj)) {
    const v = obj[n]; // 报错
    sum += Math.abs(v);
  }

  return sum;
}
```
上面示例中，函数`getSum()`要求传入参数的类型是`myObj`，但是实际上所有与`myObj`兼容的对象都可以传入。这会导致`const v = obj[n]`这一行报错，原因是`obj[n]`取出的属性值不一定是数值`（number）`，使得变量v的类型被推断为`any`。如果项目设置为不允许变量类型推断为any，代码就会报错。

解决方法：

1. 直接调用变量的属性：
```ts
type MyObj = {
  x: number;
  y: number;
};

function getSum(obj: MyObj) {
  return Math.abs(obj.x) + Math.abs(obj.y);
}
```

2. 使用类型断言：
```ts
type myObj = {
    x: number;
    y: number;
};

function getSum(obj: myObj) {
    let sum = 0;

    for (const n of Object.keys(obj)) {
        const i = n as keyof myObj;
        const v = obj[i]; // 报错
        sum += Math.abs(v);
    }

    return sum;
}
```

3. 索引签名:

```ts
type myObj = {
    [key: string]: string | number;
    x: number;
    y: number;
};

function getSum(obj: myObj) {
    let sum = 0;

    for (const n of Object.keys(obj)) {
        const v = obj[n];
        if (typeof v === 'number') {
            sum += Math.abs(v);
        }
    }

    return sum;
}
```

4. 编译选项

关闭`noImplicitAny`选项，这样TypeScript就不会默认将表达式的类型视为`any`。

### 严格字面量检查

如果对象使用字面量表示，会触发 TypeScript 的严格字面量检查（strict object literal checking）。如果字面量的结构跟类型定义的不一样（比如多出了未定义的属性），就会报错。

```ts
const point: {
  x: number;
  y: number;
} = {
  x: 1,
  y: 1,
  z: 1, // 报错
};
```
如果等号右边不是字面量，而是一个变量，根据结构类型原则，是不会报错的。

```ts
const myPoint = {
  x: 1,
  y: 1,
  z: 1,
};

const point: {
  x: number;
  y: number;
} = myPoint; // 正确
```

规避严格字面量检查的方法：

* 可以使用中间变量。

* 如果你确认字面量没有错误，也可以使用`as`类型断言规避严格字面量检查。

* 属性的字符串索引（[x: string]）

* 编译器选项`suppressExcessPropertyErrors`，可以关闭多余属性检查

### 最小可选属性规则

如果一个对象的所有属性都是可选的，会触发最小可选属性规则。

最小可选属性规则: 当一个对象的所有属性都是可选的，必须至少存在一个可选属性，不能所有可选属性都不存在，且这条规则无法通过中间变量规避。

```ts
type Options = {
  a?: number;
  b?: number;
  c?: number;
};

// 报错
const obj: Options = {
  d: 123,
};

// 无法通过中间变量规避
const myOptions = { d: 123 };

const obj: Options = myOptions; // 报错

// 设置a后，不报错
const obj: Options = {
  a: 23,
  d: 123,
};
```

### 空对象

空对象是 TypeScript 的一种特殊值，也是一种特殊类型。

```ts
const obj = {}; // 等同于： const obj: {} = {};
obj.prop = 123; // 报错
```

空对象没有自定义属性，所以对自定义属性赋值就会报错。空对象只能使用继承的属性，即继承自原型对象`Object.prototype`的属性。

```ts
obj.toString(); // 正确
```

空对象作为类型，其实是`Object`类型的简写形式。

```ts
let d: {};
// 等同于
// let d:Object;

d = {};
d = { x: 1 };
d = "hello";
d = 2;
```

如果确实需要分步声明，一个比较好的方法是，使用扩展运算符`（...）`合成一个新对象。

```ts
const pt0 = {};
const pt1 = { x: 3 };
const pt2 = { y: 4 };

const pt = {
  ...pt0,
  ...pt1,
  ...pt2,
};
```

## interface 接口

interface 是对象的模板，可以看作是一种类型约定，中文译为“接口”。使用了某个模板的对象，就拥有了指定的类型结构。

```ts
interface Person {
  firstName: string;
  lastName: string;
  age: number;
}
```

实现该接口很简单，只要指定它作为对象的类型即可。

```ts
const p: Person = {
  firstName: "John",
  lastName: "Smith",
  age: 25,
};
```

方括号运算符可以取出 interface 某个属性的类型。

```ts
interface Foo {
  a: string;
}

type A = Foo["a"]; // string
```

interface 可以表示对象的各种语法，它的成员有 5 种形式。

(1) 对象属性
```ts
interface Point {
  x: number;
  y: number;
}
```

(2) 对象的属性索引
```ts
interface A {
  [prop: string]: number;
}
```
属性索引共有string、number和symbol三种类型。

一个接口中，最多只能定义一个`字符串`索引。字符串索引会约束该类型中所有名字为字符串的属性。
```ts
interface MyObj {
  [prop: string]: number;
  a: boolean; // 编译错误
}

// 不是字符串索引可以多个
interface Person {
    [key: number]: string;
    [key: symbol]: string;
}
```

(3) 对象方法

对象的方法共有三种写法。
```ts
// 写法一
interface A {
  f(x: boolean): string;
}

// 写法二
interface B {
  f: (x: boolean) => string;
}

// 写法三
interface C {
  f: { (x: boolean): string };
}
```

属性名可以采用表达式，所以下面的写法也是可以的。

```ts
const f = "f";

interface A {
  [f](x: boolean): string;
}
```

类型方法可以重载。
```ts
interface A {
  f(): number;
  f(x: boolean): boolean;
  f(x: string, y: string): string;
}
```

interface 里面的函数重载，不需要给出实现。但是，由于对象内部定义方法时，无法使用函数重载的语法，所以需要额外在对象外部给出函数方法的实现。

```ts
interface A {
  f(): number;
  f(x: boolean): boolean;
  f(x: string, y: string): string;
}

function MyFunc(): number;
function MyFunc(x: boolean): boolean;
function MyFunc(x: string, y: string): string;
function MyFunc(x?: boolean | string, y?: string): number | boolean | string {
  if (x === undefined && y === undefined) return 1;
  if (typeof x === "boolean" && y === undefined) return true;
  if (typeof x === "string" && typeof y === "string") return "hello";
  throw new Error("wrong parameters");
}

const a: A = {
  f: MyFunc,
};
```

(4) 函数

interface 也可以用来声明独立的函数。

```ts
interface Add {
  (x: number, y: number): number;
}

const myAdd: Add = (x, y) => x + y;
```

(5) 构造函数

interface 内部可以使用`new`关键字，表示构造函数。

```ts
interface ErrorConstructor {
  new (message?: string): Error;
}
```

### interface 的继承

`interface` 可以继承其他类型，主要有下面几种情况。

### interface 继承 interface

`interface` 可以使用 `extends` 关键字，继承其他 `interface`。

```ts
interface Shape {
  name: string;
}

interface Circle extends Shape {
  radius: number;
}
```

interface 允许多重继承。

```ts
interface Style {
  color: string;
}

interface Shape {
  name: string;
}

interface Circle extends Style, Shape {
  radius: number;
}
```

如果子接口与父接口存在同名属性，那么子接口的属性会覆盖父接口的属性。注意，子接口与父接口的同名属性必须是类型兼容的，不能有冲突，否则会报错。

```ts
interface Foo {
  id: string;
}

interface Bar extends Foo {
  id: number; // 报错
}
```

多重继承时，如果多个父接口存在同名属性，那么这些同名属性不能有类型冲突，否则会报错。

```ts
interface Foo {
  id: string;
}

interface Bar {
  id: number;
}

// 报错
interface Baz extends Foo, Bar {
  type: string;
}
```

### interface 继承 type


`interface` 可以继承 `type` 命令定义的`对象类型`。

```ts
type Country = {
  name: string;
  capital: string;
};

interface CountryWithPop extends Country {
  population: number;
}
```

### interface 继承 class

`interface` 可以继承 `class` 命令定义的`类`。

```ts
class A {
  x: string = "";

  y(): boolean {
    return true;
  }
}

interface B extends A {
  z: number;
}
```

### 接口合并

多个同名接口会合并成一个接口。

```ts
interface Box {
  height: number;
  width: number;
}

interface Box {
  length: number;
}
```

这样的设计主要是为了兼容 JavaScript 的行为。JavaScript 开发者常常对全局对象或者外部库，添加自己的属性和方法。那么，只要使用 interface 给出这些自定义属性和方法的类型，就能自动跟原始的 interface 合并，使得扩展外部类型非常方便。

举例来说，Web 网页开发经常会对windows对象和document对象添加自定义属性，但是 TypeScript 会报错，因为原始定义没有这些属性。解决方法就是把自定义属性写成 interface，合并进原始定义。

```ts
interface Document {
  foo: string;
}

document.foo = "hello";
```

同名接口合并时，同一个属性如果有多个类型声明，彼此不能有类型冲突。

```ts
interface A {
  a: number;
}

interface A {
  a: string; // 报错
}
```

同名接口合并时，如果同名方法有不同的类型声明，那么会发生函数重载。而且，后面的定义比前面的定义具有更高的优先级。

```ts
interface Cloner {
  clone(animal: Animal): Animal;
}

interface Cloner {
  clone(animal: Sheep): Sheep;
}

interface Cloner {
  clone(animal: Dog): Dog;
  clone(animal: Cat): Cat;
}

// 等同于
interface Cloner {
  clone(animal: Dog): Dog;
  clone(animal: Cat): Cat;
  clone(animal: Sheep): Sheep;
  clone(animal: Animal): Animal;
}

```

这个规则有一个例外。同名方法之中，如果有一个参数是字面量类型，字面量类型有更高的优先级。
```ts
interface A {
  f(x: "foo"): boolean;
}

interface A {
  f(x: any): void;
}

// 等同于
interface A {
  f(x: "foo"): boolean;
  f(x: any): void;
}
```

一个实际的例子是 Document 对象的createElement()方法，它会根据参数的不同，而生成不同的 HTML 节点对象。
```ts
interface Document {
  createElement(tagName: any): Element;
}
interface Document {
  createElement(tagName: "div"): HTMLDivElement;
  createElement(tagName: "span"): HTMLSpanElement;
}
interface Document {
  createElement(tagName: string): HTMLElement;
  createElement(tagName: "canvas"): HTMLCanvasElement;
}

// 等同于
interface Document {
  createElement(tagName: "canvas"): HTMLCanvasElement;
  createElement(tagName: "div"): HTMLDivElement;
  createElement(tagName: "span"): HTMLSpanElement;
  createElement(tagName: string): HTMLElement;
  createElement(tagName: any): Element;
}
```

如果两个 interface 组成的联合类型存在同名属性，那么该属性的类型也是联合类型。

```ts
interface Circle {
  area: bigint;
}

interface Rectangle {
  area: number;
}

declare const s: Circle | Rectangle;

s.area; // bigint | number
```

### interface 与 type 的异同

`interface` 命令与 `type` 命令作用类似，都可以表示对象类型。

很多对象类型即可以用 `interface` 表示，也可以用 `type` 表示。而且，两者往往可以换用，几乎所有的 `interface` 命令都可以改写为 `type` 命令。

它们的相似之处，首先表现在都能为对象类型起名。

```ts
type Country = {
  name: string;
  capital: string;
};

interface Coutry {
  name: string;
  capital: string;
}
```

interface 与 type 的区别有下面几点:

（1）`type` 能够表示非对象类型，而 `interface` 只能表示对象类型（包括数组、函数等）。

（2）`interface` 可以继承其他类型，`type` 不支持继承。

（3）同名 `interface` 会自动合并，同名 `type` 则会报错。也就是说，TypeScript 不允许使用 `type` 多次定义同一个类型。

（4）`interface` 不能包含属性映射（mapping），`type` 可以，详见《映射》一章。

（5）`this` 关键字只能用于 `interface`。

```ts
// 正确
interface Foo {
  add(num: number): this;
}

// 报错
type Foo = {
  add(num: number): this;
};
```

（6）`type` 可以扩展原始数据类型，`interface` 不行。（无法使用，TS也不支持扩展原始数据类型）

```ts
// 正确
type MyStr = string & {
  type: "new";
};

// 报错
interface MyStr extends string {
  type: "new";
}
```

（7）`interface` 无法表达某些复杂类型（比如交叉类型和联合类型），但是 `type` 可以。

```ts
type A = {
  /* ... */
};
type B = {
  /* ... */
};

type AorB = A | B;
type AorBwithName = AorB & {
  name: string;
};
```

综上所述，如果有复杂的类型运算，那么没有其他选择只能使用type；一般情况下，interface灵活性比较高，便于扩充类型或自动合并，建议优先使用。

## class 类型
