---
title: 类型推论
date: 2023-01-07 15:36:15
order: 3
categories: 
  - 笔记
tags: 
  - TypeScript
---

## 基础

TypeScript 里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。

以下代码虽然没有指定类型，但是会在编译的时候报错：

```js
let myFavoriteNumber = "seven";
myFavoriteNumber = 7;

// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.
```

事实上，它等价于：

```js
let myFavoriteNumber: string = "seven";
myFavoriteNumber = 7;

// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.
```

如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 `any` 类型而完全不被类型检查：

```js
let myFavoriteNumber;
myFavoriteNumber = "seven";
myFavoriteNumber = 7;
```

## 最佳通用类型

当需要从几个表达式中推断类型时候，会使用这些表达式的类型来推断出一个最合适的通用类型。例如，

```js
let x = [0, 1, null];
```

为了推断 x 的类型，我们必须考虑所有元素的类型。 这里有两种选择： `number`和`null`。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。

由于最终的通用类型取自候选类型，有些时候候选类型共享相同的通用类型，但是却没有一个类型能做为所有候选类型的类型。例如：

```js
let zoo = [new Rhino(), new Elephant(), new Snake()];
```

这里，我们想让 zoo 被推断为 Animal[]类型，但是这个数组里没有对象是 Animal 类型的，因此不能推断出这个结果。 为了更正，当候选类型不能使用的时候我们需要明确的指出类型：

```js
let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];
```

如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，`(Rhino | Elephant | Snake)[]`。

## 上下文类型

TypeScript 类型推论也可能按照相反的方向进行。 这被叫做“按上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。比如：

```js
window.onmousedown = function (mouseEvent) {
  console.log(mouseEvent.button); //<- Error
};
```

这个例子会得到一个类型错误，TypeScript 类型检查器使用`Window.onmousedown`函数的类型来推断右边函数表达式的类型。 因此，就能推断出 `mouseEvent`参数的类型了。 如果函数表达式不是在上下文类型的位置， `mouseEvent`参数的类型需要指定为`any`，这样也不会报错了。

如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。 重写上面的例子：

```js
window.onmousedown = function (mouseEvent: any) {
  console.log(mouseEvent.button); //<- Now, no error is given
};
```

这个函数表达式有明确的参数类型注解，上下文类型被忽略。 这样的话就不报错了，因为这里不会使用到上下文类型。

上下文归类会在很多情况下使用到。 通常包含函数的参数，赋值表达式的右边，类型断言，对象成员和数组字面量和返回值语句。 上下文类型也会做为最佳通用类型的候选类型。比如：

```js
function createZoo(): Animal[] {
  return [new Rhino(), new Elephant(), new Snake()];
}
```

这个例子里，最佳通用类型有 4 个候选者：`Animal`，`Rhino`，`Elephant和Snake`。 当然， `Animal`会被做为最佳通用类型。
