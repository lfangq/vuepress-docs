import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,e as t}from"./app-6ixsUJ27.js";const e={},p=t(`<h3 id="_1-定义" tabindex="-1"><a class="header-anchor" href="#_1-定义"><span>1. 定义</span></a></h3><p><code>this</code> 就是一个对象，<code>this</code> 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</p><h3 id="_2-this-绑定规则" tabindex="-1"><a class="header-anchor" href="#_2-this-绑定规则"><span>2. this 绑定规则</span></a></h3><p><code>this</code>绑定主要分为四种：</p><ul><li>默认绑定</li><li>隐式绑定</li><li>显式绑定</li><li>new绑定</li></ul><p>只要搞清楚这四种绑定规则，我们在一般的项目中以及能够判断出 <code>this</code> 指向哪儿了！</p><h4 id="_2-1-默认绑定" tabindex="-1"><a class="header-anchor" href="#_2-1-默认绑定"><span>2.1 默认绑定</span></a></h4><p>我们比较常见的一种函数调用类型就是独立函数的调用，形如<code>foo()</code>等。这个时候的 <code>this</code> 绑定就是采用的<code>默认绑定规则</code>。</p><p>代码如下：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">&#39;小猪课堂&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">// Window{}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 小猪课堂</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 小猪课堂</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上段代码非常简单，我们在全局作用域中定义了一个变量<code>name</code>，然后我们在函数 <code>foo</code> 中使用<code>this.name</code>，输出的结果就是全局变量<code>name</code>，这说明我们 <code>this</code> 指向了全局作用域，也就是说 <code>this</code> 绑定到了 <code>window</code> 对象上。</p><p>函数的这种调用方式就被称为默认绑定，默认绑定规则下的 <code>this</code> 指向全局对象。</p><p>我们可以给默认绑定给个定义：</p><blockquote><p>当函数不带用任何修饰进行调用时，此时 this 的绑定就是默认绑定规则，this 指向全局对象。</p></blockquote><div class="hint-container warning"><p class="hint-container-title">注意</p><p><code>let</code>变量声明不会绑定在<code>window</code>上面，只有<code>var</code>声明的才会，这是需要注意的。除此之外，严格模式下上段代码的 <code>this</code> 是 <code>undefined</code>，比如下面这段代码：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">&#39;小猪课堂&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token string">&#39;use strict&#39;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught TypeError: Cannot read properties of undefined (reading &#39;name&#39;)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上段代码可以看出，默认绑定规则下，<code>this</code> 绑定到了全局对象，当然这与函数调用位置有关。但是<code>严格模式</code>下，<code>this</code> 的绑定与函数调用位置无关。</p></div><h4 id="_2-2-隐式绑定" tabindex="-1"><a class="header-anchor" href="#_2-2-隐式绑定"><span>2.2 隐式绑定</span></a></h4><p>前面的默认绑定规则很好理解，因为我们的函数执行上下文就是全局作用域，this 自然而然绑定到了全局对象上。</p><p>独立函数的调用我们可以直接看出执行上下文在哪里，但如果不是独立函数调用，比如下面代码。</p><p>代码如下：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 小猪课堂</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;小猪课堂&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">foo</span><span class="token operator">:</span> foo
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上段代码我们在 obj 对象中引用了函数 foo，然后我们使用 obj.foo（函数别名）的方式调用了该函数，此时不是独立函数调用，我们不能使用默认绑定规则。</p><p>此时 this 的绑定规则称为隐式绑定规则，因为我们不能直接看出函数的调用位置，它的实际调用位置在 obj 对象里面，调用 foo 时，它的执行上下文对象为 obj 对象，所以 this 将会被绑定到 obj 对象上，所以我们函数中的 this.name 其实就是obj.name。这就是我们的隐式绑定规则。</p><p>注意：</p><p>如果我们调用函数时有多个引用调用，比如obj1.obj2.foo()。这个时候函数 foo 中的 this 指向哪儿呢？其实不管引用链多长，this 的绑定都由最顶层调用位置确定，即obj1.obj2.foo()的 this 还是绑定带 obj2。</p><p>隐式绑定中 this 丢失</p><p>在隐式绑定规则中，我们认为谁调用了函数，this 就绑定谁，比如 obj.foo 中 this 就绑定到 obj，但是有一些情况比较特殊，即使采用的隐式绑定规则，但是 this 并没有按照我们的想法去绑定，这就是所谓的隐式绑定 this 丢失，常见于回调函数中。</p><p>代码如下：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 小猪课堂</span>
<span class="token punctuation">}</span>


<span class="token keyword">function</span> <span class="token function">doFoo</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 函数调用位置</span>
<span class="token punctuation">}</span>


<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;张三&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">foo</span><span class="token operator">:</span> foo
<span class="token punctuation">}</span>
<span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">&#39;小猪课堂&#39;</span><span class="token punctuation">;</span>
<span class="token function">doFoo</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 小猪课堂</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上段代码中我们很容易会以为 foo 绑定的 this 是 obj 对象，因为我们使用了 obj.foo 的方式，这种方式就是遵循隐式绑定规则。但是事实上 this 却绑定到了全局对象上去，这是因为我们在 doFoo 函数中调用 fn 时，这里才是函数的实际调用位置，此时是独立函数调用，所以 this 指向了全局对象。</p><p>实际项目中我们容易遇到这种问题的场景可能就是定时器了，比如下面的代码：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这种写法就很容易造成 this 丢失。</p><h4 id="_2-3-显式绑定" tabindex="-1"><a class="header-anchor" href="#_2-3-显式绑定"><span>2.3 显式绑定</span></a></h4><p>前面我们已经说了默认绑定和隐式绑定，其中隐式绑定我们通常是以 obj.foo 这种形式来调用函数的，目的就是为了让 foo 的 this 绑定到 obj 对象上。</p><p>这个时候，如果我们不想通过 obj.foo 的形式调用函数，我们想要很明确的将函数的 this 绑定在某个对象上。那么可以使用 call、apply 等方法，这就是所谓的显式绑定规则。</p><p>代码如下：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 小猪课堂</span>
<span class="token punctuation">}</span>


<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;小猪课堂&#39;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>


<span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上段代码我们利用 call 方法直接将 foo 函数内部的 this 指向了 obj 对象，这就是显式绑定。</p><p>虽然显式绑定让我们很清楚的知道了函数中的 this 绑定到了哪个对象上，但是它还是无法结局我们 this 绑定丢失的问题，就比如下面这种写法：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 小猪课堂</span>
<span class="token punctuation">}</span>


<span class="token keyword">function</span> <span class="token function">doFoo</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 函数调用位置</span>
<span class="token punctuation">}</span>


<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;张三&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">foo</span><span class="token operator">:</span> foo
<span class="token punctuation">}</span>
<span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">&#39;小猪课堂&#39;</span><span class="token punctuation">;</span>
<span class="token function">doFoo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> obj<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 小猪课堂</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上段代码我们虽然使用 call 来更改 this 绑定，但是最终结果却是没有用的。</p><p>虽然显式绑定本身不能解决 this 绑定丢失的问题，但是我们可以通过变通的方式来解决这个问题，也被称作硬绑定。</p><p>硬绑定：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 小猪课堂</span>
<span class="token punctuation">}</span>


<span class="token keyword">function</span> <span class="token function">doFoo</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 函数调用位置</span>
<span class="token punctuation">}</span>


<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;张三&#39;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> <span class="token function-variable function">bar</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">&#39;小猪课堂&#39;</span><span class="token punctuation">;</span>
<span class="token function">doFoo</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 张三</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span>bar<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 张三</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其实思路也比较简单，出现 this 绑定丢失原因无非就是我们传入的回调函数在被执行时，this 绑定规则变为了默认绑定，那么为了解决这个问题，我们不妨在封装一个函数，将 foo 函数的 this 显式绑定到 obj 对象上去即可。</p><p>这里提一点，下面写法是错误的：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token function">doFoo</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>因为回调函数是在 doFoo 里面执行的，上面的写法相当于 foo 函数立即执行了。</p><p>补充：</p><p>其实我们的 bind 函数就是一个硬绑定，大家想一想，bind 函数是不是创建一个新的函数，然后将 this 指定，是不是就和我们下面这段代码的效果一样。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">let</span> <span class="token function-variable function">bar</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
<span class="token punctuation">}</span>


<span class="token comment">// bind 形式</span>
<span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-4-new绑定" tabindex="-1"><a class="header-anchor" href="#_2-4-new绑定"><span>2.4 new绑定</span></a></h4><p>new 关键词相信大家都知道或者使用过吧，这就是我们将要将的第 4 种 this 绑定，叫做 new 绑定。</p><p>想要知道 new 绑定规则，我们就很有必要知道一个当我们 new 一个对象的时候做了什么，或者说 new 关键词会做哪些操作。我们这里简单总结一下，具体的 new 的过程还需要大家自行下来好好学学。</p><p>使用 new 来调用函数时，会执行下面操作：</p><ol><li>创建一个全新的对象</li><li>这个新对象会被执行原型连接</li><li>这个新对象会绑定到函数调用的 this</li><li>如果函数没有返回其它对象，那么 new 表达式种的函数调用会自动返回这个新对象</li></ol><p>我们可以看到 new 的操作中就有 this 的绑定，我们在来看看代码。</p><p>代码如下：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo</span><span class="token punctuation">(</span><span class="token string">&#39;小猪课堂&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 小猪课堂</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上段代码我们使用 new 关键词调用了 foo 函数，大家注意这不是默认调用规则，这是 new 绑定规则。</p><h3 id="_3-优先级" tabindex="-1"><a class="header-anchor" href="#_3-优先级"><span>3. 优先级</span></a></h3>`,61),o=[p];function c(i,l){return a(),s("div",null,o)}const r=n(e,[["render",c],["__file","this指向.html.vue"]]),k=JSON.parse('{"path":"/posts/this%E6%8C%87%E5%90%91.html","title":"this指向","lang":"zh-CN","frontmatter":{"title":"this指向","date":"2024-04-01T16:58:06.000Z","categories":["JavaScript"],"tags":["JavaScript"],"description":"1. 定义 this 就是一个对象，this 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。 2. this 绑定规则 this绑定主要分为四种： 默认绑定 隐式绑定 显式绑定 new绑定 只要搞清楚这四种绑定规则，我们在一般的项目中以及能够判断出 this 指向哪儿了！ 2.1 默认绑定 我们比较常见的一种函数调用类型就是独立函数...","head":[["meta",{"property":"og:url","content":"https://www.lfangq.top/posts/this%E6%8C%87%E5%90%91.html"}],["meta",{"property":"og:site_name","content":"Lfangq"}],["meta",{"property":"og:title","content":"this指向"}],["meta",{"property":"og:description","content":"1. 定义 this 就是一个对象，this 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。 2. this 绑定规则 this绑定主要分为四种： 默认绑定 隐式绑定 显式绑定 new绑定 只要搞清楚这四种绑定规则，我们在一般的项目中以及能够判断出 this 指向哪儿了！ 2.1 默认绑定 我们比较常见的一种函数调用类型就是独立函数..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-30T01:54:59.000Z"}],["meta",{"property":"article:author","content":"Lfangq"}],["meta",{"property":"article:tag","content":"JavaScript"}],["meta",{"property":"article:published_time","content":"2024-04-01T16:58:06.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-30T01:54:59.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"this指向\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-04-01T16:58:06.000Z\\",\\"dateModified\\":\\"2024-05-30T01:54:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Lfangq\\",\\"url\\":\\"https://www.lfangq.top/\\"}]}"]]},"headers":[{"level":3,"title":"1. 定义","slug":"_1-定义","link":"#_1-定义","children":[]},{"level":3,"title":"2. this 绑定规则","slug":"_2-this-绑定规则","link":"#_2-this-绑定规则","children":[]},{"level":3,"title":"3. 优先级","slug":"_3-优先级","link":"#_3-优先级","children":[]}],"git":{"createdTime":1717034099000,"updatedTime":1717034099000,"contributors":[{"name":"lfangq","email":"2251234678@qq.com","commits":1}]},"readingTime":{"minutes":6.89,"words":2068},"filePathRelative":"posts/this指向.md","localizedDate":"2024年4月1日","excerpt":"","autoDesc":true}');export{r as comp,k as data};
