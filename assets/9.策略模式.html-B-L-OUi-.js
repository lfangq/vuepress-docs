import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as a,c as t,b as e,d as p,o}from"./app-DjqQ9Aow.js";const c={},i=p(`<h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span>定义</span></a></h3><p>策略模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。</p><p>策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p><p>简而言之，就是策略模式准备了一组算法，并将每个算法进行封装，使它们之间可用相互替换。</p><p>策略模式除了用来封装算法，也可以用来封装一系列的&quot;业务规则&quot;，只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以用策略模式来封装它们。</p><h3 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例</span></a></h3><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 策略类</span>
<span class="token comment">// 所有跟计算奖金有关的逻辑不再放在环境类Context中，而是分布在各个策略对象中。</span>
<span class="token keyword">let</span> strategies <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 每个策略对象负责的算法被各自封装在对象内部</span>
    <span class="token string-property property">&quot;RegularCard&quot;</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span> <span class="token parameter">deposit</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> deposit <span class="token operator">*</span> <span class="token number">0.1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token string-property property">&quot;GoldCard&quot;</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span> <span class="token parameter">deposit</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> deposit <span class="token operator">*</span> <span class="token number">0.2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token string-property property">&quot;PlatinumCard&quot;</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span> <span class="token parameter">deposit</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> deposit <span class="token operator">*</span> <span class="token number">0.3</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 奖金类(对应环境类\`calculateBonusContext)</span>
<span class="token comment">// 环境类Context并没有计算奖金的能力，而是把这个职责委托给了某个策略对象</span>
<span class="token keyword">let</span> <span class="token function-variable function">calculateBonus</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">vipLevel<span class="token punctuation">,</span>deposit</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> strategies<span class="token punctuation">[</span>vipLevel<span class="token punctuation">]</span><span class="token punctuation">(</span>deposit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 替换Context中当前保存的策略对象，便能执行不同的算法来得到我们想要的结果</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;GoldCard&#39;</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span> <span class="token comment">// 输出：400</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;RegularCard&#39;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment">// 输出：100</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,7);function l(r,u){const n=a("Mermaid");return o(),t("div",null,[e(n,{id:"mermaid-0",code:"eJzT1dXlKsksyUm1Uni+dtrzqUufrVj4dE8/F1BcQYErvSixIEPBJ4hLAQgco5+uW/SsY/vz1etjFYDSLxs6n3WvBLLsFJyiIZqfrt/5YuPCWLByJ5CaFxuan09ZAVbjHP183fRnm6caYpd2gUobYZd2hUobx3IVlyZB3AV1MUTVs2k7gdJAvU5cqXkpChiqnm/cDZR0BmIXIHYFKeICAHjRao8="}),i])}const k=s(c,[["render",l],["__file","9.策略模式.html.vue"]]),v=JSON.parse('{"path":"/notes/design-mode/9.%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html","title":"策略模式","lang":"zh-CN","frontmatter":{"title":"策略模式","date":"2024-05-21T13:56:45.000Z","order":9,"icon":"layer-group","category":["笔记"],"tags":["设计模式"],"description":"定义 策略模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。 策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。 简而言之，就是策略模式准备了一组算法，并将每个算法进行封装，使它们之间可用相互替换。 策略模式除了用来封装算法，也可...","head":[["meta",{"property":"og:url","content":"https://www.lfangq.top/notes/design-mode/9.%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html"}],["meta",{"property":"og:site_name","content":"Lfangq"}],["meta",{"property":"og:title","content":"策略模式"}],["meta",{"property":"og:description","content":"定义 策略模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。 策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。 简而言之，就是策略模式准备了一组算法，并将每个算法进行封装，使它们之间可用相互替换。 策略模式除了用来封装算法，也可..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-05T05:25:35.000Z"}],["meta",{"property":"article:author","content":"Lfangq"}],["meta",{"property":"article:tag","content":"设计模式"}],["meta",{"property":"article:published_time","content":"2024-05-21T13:56:45.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-05T05:25:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"策略模式\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-05-21T13:56:45.000Z\\",\\"dateModified\\":\\"2024-06-05T05:25:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Lfangq\\",\\"url\\":\\"https://www.lfangq.top/\\"}]}"]]},"headers":[{"level":3,"title":"定义","slug":"定义","link":"#定义","children":[]},{"level":3,"title":"示例","slug":"示例","link":"#示例","children":[]}],"git":{"createdTime":1716882891000,"updatedTime":1717565135000,"contributors":[{"name":"lfangq","email":"2251234678@qq.com","commits":2}]},"readingTime":{"minutes":1.58,"words":474},"filePathRelative":"notes/design-mode/9.策略模式.md","localizedDate":"2024年5月21日","excerpt":"","autoDesc":true}');export{k as comp,v as data};
