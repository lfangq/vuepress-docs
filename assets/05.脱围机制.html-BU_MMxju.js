import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,e}from"./app-DbdGz4CT.js";const t={},p=e(`<h2 id="使用-ref-引用值" tabindex="-1"><a class="header-anchor" href="#使用-ref-引用值"><span>使用 ref 引用值</span></a></h2><p>当你希望组件“记住”某些信息，但又不想让这些信息 触发新的渲染 时，你可以使用 ref：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>与 state 一样，ref 在重新渲染之间由 React 保留。但是，设置 state 会重新渲染组件，而更改 ref 不会！你可以通过 ref.current 属性访问该 ref 的当前值。</p><h2 id="使用-ref-操作-dom" tabindex="-1"><a class="header-anchor" href="#使用-ref-操作-dom"><span>使用 ref 操作 DOM</span></a></h2><p>由于 React 会自动更新 DOM 以匹配渲染输出，因此组件通常不需要操作 DOM。但是，有时可能需要访问由 React 管理的 DOM 元素——例如聚焦节点、滚动到此节点，以及测量它的尺寸和位置。React 没有内置的方法来执行此类操作，所以需要一个指向 DOM 节点的 ref 来实现。例如，点击按钮将使用 ref 聚焦输入框：</p><iframe src="https://codesandbox.io/embed/qkkzqh?view=Editor+%2B+Preview&amp;module=%2Fsrc%2FApp.js" style="width:100%;height:400px;border:0;border-radius:4px;overflow:hidden;" title="react.dev" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><h2 id="使用-ref-回调管理-ref-列表" tabindex="-1"><a class="header-anchor" href="#使用-ref-回调管理-ref-列表"><span>使用 ref 回调管理 ref 列表</span></a></h2><p>将函数传递给 ref 属性。这称为 <code>ref 回调</code>。当需要设置 ref 时，React 将传入 DOM 节点来调用你的 ref 回调，并在需要清除它时传入 null 。这使你可以维护自己的<code>数组</code>或 <code>Map</code>，并通过其索引或某种类型的 ID 访问任何 ref。</p><iframe src="https://codesandbox.io/embed/f3hdpz?view=Editor+%2B+Preview&amp;module=%2Fsrc%2FApp.js" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden;" title="react.dev" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><h2 id="访问另一个组件的-dom-节点" tabindex="-1"><a class="header-anchor" href="#访问另一个组件的-dom-节点"><span>访问另一个组件的 DOM 节点</span></a></h2><p>React 不允许组件访问其他组件的 DOM 节点。甚至自己的子组件也不行！这是故意的。Refs 是一种脱围机制，应该谨慎使用。手动操作 另一个 组件的 DOM 节点会使你的代码更加脆弱。</p><p>相反，想要 暴露其 DOM 节点的组件必须选择该行为。一个组件可以指定将它的 ref “转发”给一个子组件。下面是 MyInput 如何使用 forwardRef API：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> forwardRef <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> MyInput <span class="token operator">=</span> <span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> ref</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>input <span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span> ref<span class="token operator">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><iframe src="https://codesandbox.io/embed/4mk6d2?view=Editor+%2B+Preview&amp;module=%2Fsrc%2FApp.js" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden;" title="react.dev" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><h2 id="使用-useimperativehandle-命令句柄限制暴露的api" tabindex="-1"><a class="header-anchor" href="#使用-useimperativehandle-命令句柄限制暴露的api"><span>使用 useImperativeHandle 命令句柄限制暴露的API</span></a></h2><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code> <span class="token keyword">import</span> <span class="token punctuation">{</span> useRef <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span><span class="token punctuation">;</span>
 <span class="token keyword">const</span> realInputRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useImperativeHandle</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token comment">// 只暴露 focus，没有别的</span>
    <span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      realInputRef<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>input <span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span> ref<span class="token operator">=</span><span class="token punctuation">{</span>realInputRef<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="react-何时添加-refs" tabindex="-1"><a class="header-anchor" href="#react-何时添加-refs"><span>React 何时添加 refs</span></a></h2><p>在 React 中，每次更新都分为 两个阶段：</p><ul><li><p>在 渲染 阶段， React 调用你的组件来确定屏幕上应该显示什么。</p></li><li><p>在 提交 阶段， React 把变更应用于 DOM。</p></li></ul><p>通常，你 不希望 在渲染期间访问 refs。这也适用于保存 DOM 节点的 refs。在第一次渲染期间，DOM 节点尚未创建，因此 ref.current 将为 null。在渲染更新的过程中，DOM 节点还没有更新。所以读取它们还为时过早。</p><p>React 在提交阶段设置 ref.current。在更新 DOM 之前，React 将受影响的 ref.current 值设置为 null。更新 DOM 后，React 立即将它们设置到相应的 DOM 节点。</p><p>通常，你将从事件处理器访问 refs。 如果你想使用 ref 执行某些操作，但没有特定的事件可以执行此操作，你可能需要一个 effect。我们将在下一页讨论 effect。</p><h2 id="用-flushsync-同步更新-state" tabindex="-1"><a class="header-anchor" href="#用-flushsync-同步更新-state"><span>用 flushSync 同步更新 state</span></a></h2><p><code>flushSync</code> 强制 React 同步更新（“刷新”）DOM。</p><iframe src="https://codesandbox.io/embed/x7fr2r?view=Editor+%2B+Preview&amp;module=%2Fsrc%2FApp.js" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden;" title="react.dev" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><h2 id="使用-effect-实现同步" tabindex="-1"><a class="header-anchor" href="#使用-effect-实现同步"><span>使用 Effect 实现同步</span></a></h2><p>Effect 在 React 中是专有定义——由渲染引起的副作用。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><ol><li><p>在开发环境中，React 将立即运行并额外清理一次 Effect。(为了检测Effect函数没有副作用，在多次挂载不会产生bug)</p></li><li><p>在 React 中，JSX 的渲染必须是纯粹操作，不应该包含任何像修改 DOM 的副作用。</p></li></ol></div><h3 id="_1-如何编写-effect" tabindex="-1"><a class="header-anchor" href="#_1-如何编写-effect"><span>1. 如何编写 Effect</span></a></h3><p>编写 Effect 需要遵循以下三个规则：</p><ol><li><p><code>声明 Effect</code>。默认情况下，Effect 会在每次渲染后都会执行。</p></li><li><p><code>指定 Effect 依赖</code>。大多数 Effect 应该按需执行，而不是在每次渲染后都执行。例如，淡入动画应该只在组件出现时触发。连接和断开服务器的操作只应在组件出现和消失时，或者切换聊天室时执行。文章将介绍如何通过指定依赖来控制如何按需执行。</p></li><li><p><code>必要时添加清理（cleanup）函数</code>。有时 Effect 需要指定如何停止、撤销，或者清除它的效果。例如，“连接”操作需要“断连”，“订阅”需要“退订”，“获取”既需要“取消”也需要“忽略”。你将学习如何使用 清理函数 来做到这一切。</p></li></ol><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 声明Effect</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 每次渲染后都会执行此处的代码</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-指定-effect-依赖" tabindex="-1"><a class="header-anchor" href="#_2-指定-effect-依赖"><span>2. 指定 Effect 依赖</span></a></h3><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 声明Effect</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 每次渲染后都会执行此处的代码</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 依赖数组 传入 useEffect 的第二个参数，以告诉 React 跳过不必要地重新运行 Effect。</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container warning"><p class="hint-container-title">注意</p><ol><li>依赖数组的不同，将导致不同的行为。</li></ol><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这里的代码会在每次渲染后执行</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这里的代码只会在组件挂载后执行</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">//这里的代码只会在每次渲染后，并且 a 或 b 的值与上次渲染不一致时执行</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>ref 具有 稳定 的标识：React 保证 每轮渲染中调用 useRef 所产生的引用对象时，获取到的对象引用总是相同的，即获取到的对象引用永远不会改变，所以它不会导致重新运行 Effect。</li></ol><p>如果 ref 是从父组件传递的，则必须在依赖项数组中指定它。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">VideoPlayer</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> src<span class="token punctuation">,</span> isPlaying <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isPlaying<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      ref<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      ref<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">pause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>isPlaying<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 等同于</span>
<span class="token keyword">function</span> <span class="token function">VideoPlayer</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> src<span class="token punctuation">,</span> isPlaying <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isPlaying<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      ref<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      ref<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">pause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>isPlaying<span class="token punctuation">,</span> ref<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><h3 id="_3-按需添加清理-cleanup-函数" tabindex="-1"><a class="header-anchor" href="#_3-按需添加清理-cleanup-函数"><span>3. 按需添加清理（cleanup）函数</span></a></h3><p>在<code>useEffect</code> 里<code>return</code>的函数就是<code>清理（cleanup）函数</code>。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> connection <span class="token operator">=</span> <span class="token function">createConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    connection<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 清理（cleanup）函数</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      connection<span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-如何处理在开发环境中-effect-执行两次" tabindex="-1"><a class="header-anchor" href="#_4-如何处理在开发环境中-effect-执行两次"><span>4. 如何处理在开发环境中 Effect 执行两次？</span></a></h3><p>在开发环境中，React 有意重复挂载你的组件，以查找像上面示例中的错误。正确的态度是“如何修复 Effect 以便它在重复挂载后能正常工作”，而不是“如何只运行一次 Effect”。</p><p>通常的解决办法是实现清理函数。清理函数应该停止或撤销 Effect 正在执行的任何操作。简单来说，用户不应该感受到 Effect 只执行一次（如在生产环境中）和执行“挂载 → 清理 → 挂载”过程（如在开发环境中）之间的差异。</p><p>在生产环境中，只会显示发送了一条获取请求。如果开发环境中，第二次请求给你造成了困扰，最好的方法是使用一种可以删除重复请求、并缓存请求响应的解决方案：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">TodoList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> todos <span class="token operator">=</span> <span class="token function">useSomeDataLibrary</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">/api/user/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>userId<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/todos</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-effect的不同渲染" tabindex="-1"><a class="header-anchor" href="#_5-effect的不同渲染"><span>5. Effect的不同渲染</span></a></h3><ul><li><p>初始渲染</p></li><li><p>依赖项相同时的重新渲染</p></li></ul><p>所有的依赖项都是相同的，React 会忽略第二次渲染时的 Effect。所以此时 Effect 不会被调用。</p><ul><li><p>依赖项不同时的重新渲染</p></li><li><p>组件卸载</p></li><li><p>仅开发环境下的行为</p></li></ul><p>在 严格模式 下，React 在每次挂载组件后都会重新挂载组件（但是组件的 state 与 创建的 DOM 都会被保留）。它可以帮助你找出需要添加清理函数的 Effect，以及早暴露出像条件竞争那样的问题。此外，每当你在开发环境中保存更新代码文件时，React 也会重新挂载 Effect，不过这两种行为都仅限于开发环境。</p><h3 id="_6-effect-的生命周期" tabindex="-1"><a class="header-anchor" href="#_6-effect-的生命周期"><span>6. Effect 的生命周期</span></a></h3><ul><li><p>当组件被添加到屏幕上时，它会进行组件的 挂载。</p></li><li><p>当组件接收到新的 props 或 state 时，通常是作为对交互的响应，它会进行组件的 更新。</p></li><li><p>当组件从屏幕上移除时，它会进行组件的 卸载。</p></li></ul><h3 id="_7-从-effect-提取非响应式逻辑" tabindex="-1"><a class="header-anchor" href="#_7-从-effect-提取非响应式逻辑"><span>7. 从 Effect 提取非响应式逻辑</span></a></h3><p>使用 useEffectEvent 这个特殊的 Hook 从 Effect 中提取非响应式逻辑：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useEffect<span class="token punctuation">,</span> useEffectEvent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">ChatRoom</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> roomId<span class="token punctuation">,</span> theme <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> onConnected <span class="token operator">=</span> <span class="token function">useEffectEvent</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">showNotification</span><span class="token punctuation">(</span><span class="token string">&#39;Connected!&#39;</span><span class="token punctuation">,</span> theme<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Effect Event 的局限性在于你如何使用他们：</p><ul><li><p>只在 Effect 内部调用他们。</p></li><li><p>永远不要把他们传给其他的组件或者 Hook。</p></li></ul><h3 id="_8-移除-effect-依赖" tabindex="-1"><a class="header-anchor" href="#_8-移除-effect-依赖"><span>8. 移除 Effect 依赖</span></a></h3><ul><li><p>依赖应始终与代码匹配。</p></li><li><p>当你对依赖不满意时，你需要编辑的是代码。</p></li><li><p>抑制 linter 会导致非常混乱的错误，你应该始终避免它。</p></li><li><p>要移除依赖，你需要向 linter “证明”它不是必需的。</p></li><li><p>如果某些代码是为了响应特定交互，请将该代码移至事件处理的地方。</p></li><li><p>如果 Effect 的不同部分因不同原因需要重新运行，请将其拆分为多个 Effect。</p></li><li><p>如果你想根据以前的状态更新一些状态，传递一个更新函数。</p></li><li><p>如果你想读取最新值而不“反应”它，请从 Effect 中提取出一个 Effect Event。</p></li><li><p>在 JavaScript 中，如果对象和函数是在不同时间创建的，则它们被认为是不同的。</p></li><li><p>尽量避免对象和函数依赖。将它们移到组件外或 Effect 内。</p></li></ul>`,58),c=[p];function o(i,l){return a(),s("div",null,c)}const d=n(t,[["render",o],["__file","05.脱围机制.html.vue"]]),k=JSON.parse('{"path":"/notes/react/05.%E8%84%B1%E5%9B%B4%E6%9C%BA%E5%88%B6.html","title":"脱围机制","lang":"zh-CN","frontmatter":{"title":"脱围机制","date":"2024-02-21T10:49:19.000Z","order":6,"categories":["笔记"],"tags":["React"],"description":"使用 ref 引用值 当你希望组件“记住”某些信息，但又不想让这些信息 触发新的渲染 时，你可以使用 ref： 与 state 一样，ref 在重新渲染之间由 React 保留。但是，设置 state 会重新渲染组件，而更改 ref 不会！你可以通过 ref.current 属性访问该 ref 的当前值。 使用 ref 操作 DOM 由于 React ...","head":[["meta",{"property":"og:url","content":"https://www.lfangq.top/notes/react/05.%E8%84%B1%E5%9B%B4%E6%9C%BA%E5%88%B6.html"}],["meta",{"property":"og:site_name","content":"Lfangq"}],["meta",{"property":"og:title","content":"脱围机制"}],["meta",{"property":"og:description","content":"使用 ref 引用值 当你希望组件“记住”某些信息，但又不想让这些信息 触发新的渲染 时，你可以使用 ref： 与 state 一样，ref 在重新渲染之间由 React 保留。但是，设置 state 会重新渲染组件，而更改 ref 不会！你可以通过 ref.current 属性访问该 ref 的当前值。 使用 ref 操作 DOM 由于 React ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-30T01:54:59.000Z"}],["meta",{"property":"article:author","content":"Lfangq"}],["meta",{"property":"article:tag","content":"React"}],["meta",{"property":"article:published_time","content":"2024-02-21T10:49:19.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-30T01:54:59.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"脱围机制\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-02-21T10:49:19.000Z\\",\\"dateModified\\":\\"2024-05-30T01:54:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Lfangq\\",\\"url\\":\\"https://www.lfangq.top/\\"}]}"]]},"headers":[{"level":2,"title":"使用 ref 引用值","slug":"使用-ref-引用值","link":"#使用-ref-引用值","children":[]},{"level":2,"title":"使用 ref 操作 DOM","slug":"使用-ref-操作-dom","link":"#使用-ref-操作-dom","children":[]},{"level":2,"title":"使用 ref 回调管理 ref 列表","slug":"使用-ref-回调管理-ref-列表","link":"#使用-ref-回调管理-ref-列表","children":[]},{"level":2,"title":"访问另一个组件的 DOM 节点","slug":"访问另一个组件的-dom-节点","link":"#访问另一个组件的-dom-节点","children":[]},{"level":2,"title":"使用 useImperativeHandle 命令句柄限制暴露的API","slug":"使用-useimperativehandle-命令句柄限制暴露的api","link":"#使用-useimperativehandle-命令句柄限制暴露的api","children":[]},{"level":2,"title":"React 何时添加 refs","slug":"react-何时添加-refs","link":"#react-何时添加-refs","children":[]},{"level":2,"title":"用 flushSync 同步更新 state","slug":"用-flushsync-同步更新-state","link":"#用-flushsync-同步更新-state","children":[]},{"level":2,"title":"使用 Effect 实现同步","slug":"使用-effect-实现同步","link":"#使用-effect-实现同步","children":[{"level":3,"title":"1. 如何编写 Effect","slug":"_1-如何编写-effect","link":"#_1-如何编写-effect","children":[]},{"level":3,"title":"2. 指定 Effect 依赖","slug":"_2-指定-effect-依赖","link":"#_2-指定-effect-依赖","children":[]},{"level":3,"title":"3. 按需添加清理（cleanup）函数","slug":"_3-按需添加清理-cleanup-函数","link":"#_3-按需添加清理-cleanup-函数","children":[]},{"level":3,"title":"4. 如何处理在开发环境中 Effect 执行两次？","slug":"_4-如何处理在开发环境中-effect-执行两次","link":"#_4-如何处理在开发环境中-effect-执行两次","children":[]},{"level":3,"title":"5. Effect的不同渲染","slug":"_5-effect的不同渲染","link":"#_5-effect的不同渲染","children":[]},{"level":3,"title":"6. Effect 的生命周期","slug":"_6-effect-的生命周期","link":"#_6-effect-的生命周期","children":[]},{"level":3,"title":"7. 从 Effect 提取非响应式逻辑","slug":"_7-从-effect-提取非响应式逻辑","link":"#_7-从-effect-提取非响应式逻辑","children":[]},{"level":3,"title":"8. 移除 Effect 依赖","slug":"_8-移除-effect-依赖","link":"#_8-移除-effect-依赖","children":[]}]}],"git":{"createdTime":1717034099000,"updatedTime":1717034099000,"contributors":[{"name":"lfangq","email":"2251234678@qq.com","commits":1}]},"readingTime":{"minutes":8.35,"words":2505},"filePathRelative":"notes/react/05.脱围机制.md","localizedDate":"2024年2月21日","excerpt":"","autoDesc":true}');export{d as comp,k as data};
